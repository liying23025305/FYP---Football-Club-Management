
const express = require('express');
const router = express.Router();
const mysql = require('mysql2');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY || 'sk_test_REPLACE_ME');

// Remove a pending order (user-initiated)
router.post('/orders/:orderId/remove', async (req, res) => {
  const user = req.session.user;
  const orderId = req.params.orderId;
  if (!user) return res.status(401).send('Not logged in');
  try {
    // Only allow removing pending orders
    const [orders] = await connection.promise().query(
      'SELECT * FROM orders WHERE order_id = ? AND user_id = ? AND status = "pending"',
      [orderId, user.user_id]
    );
    if (!orders.length) return res.status(403).send('Order not found or not pending');
    // Delete order items first (FK constraint)
    await connection.promise().query('DELETE FROM order_items WHERE order_id = ?', [orderId]);
    // Delete the order
    await connection.promise().query('DELETE FROM orders WHERE order_id = ?', [orderId]);
    // Optionally, delete payment record if exists
    await connection.promise().query('DELETE FROM payments WHERE order_id = ?', [orderId]);
    res.redirect('/my-orders');
  } catch (err) {
    console.error('Error removing pending order:', err);
    res.status(500).send('Error removing order');
  }
});

// Update credentials for XAMPP
const connection = mysql.createConnection({
  host: 'localhost',
  user: 'root',
  password: '', // default for XAMPP
  database: 'mydb'
});

// Ensure session gear_cart exists
function ensuregear_cartSession(req) {
  if (!req.session.gear_cart) {
    req.session.gear_cart = [];
  }
}

// Show store page with category and search filtering
router.get('/store', async (req, res) => {
  try {
    const category = req.query.category;
    const search = req.query.search;
    const priceRange = req.query.priceRange ? Number(req.query.priceRange) : 1000;
    const size = req.query.size && req.query.size !== 'All' ? req.query.size : null;
    const sizeKids = req.query.sizeKids && req.query.sizeKids !== 'All' ? req.query.sizeKids : null;
    const sortBy = req.query.sortBy || 'featured';

    // Get all unique categories from gear table
    const [catResults] = await connection.promise().query('SELECT DISTINCT category FROM gear WHERE category IS NOT NULL AND category != ""');
    const categories = catResults.map(row => row.category).filter(Boolean);

    // Build SQL query with filters
    let sql = 'SELECT * FROM gear WHERE 1=1';
    let params = [];
    if (category && category !== 'All') {
      sql += ' AND category = ?';
      params.push(category);
    }
    if (size) {
      sql += ' AND (size = ? OR size IS NULL OR size = "")'; // If you have size column, otherwise skip
      params.push(size);
    }
    if (sizeKids) {
      sql += ' AND (size_kids = ? OR size_kids IS NULL OR size_kids = "")'; // If you have size_kids column
      params.push(sizeKids);
    }
    if (search) {
      sql += ' AND gear_name LIKE ?';
      params.push(`%${search}%`);
    }
    sql += ' AND price_per_unit <= ?';
    params.push(priceRange);

    // Sorting
    if (sortBy === 'priceLow') {
      sql += ' ORDER BY price_per_unit ASC';
    } else if (sortBy === 'priceHigh') {
      sql += ' ORDER BY price_per_unit DESC';
    } else if (sortBy === 'name') {
      sql += ' ORDER BY gear_name ASC';
    } else {
      sql += ' ORDER BY gear_id DESC'; // featured or default
    }

    const [results] = await connection.promise().query(sql, params);
    let products = results.map(item => ({
      id: item.gear_id,
      name: item.gear_name,
      image: item.gear_image,
      price: Number(item.price_per_unit).toFixed(2),
      category: item.category
    }));

    // Find most popular (example: highest price, or you can use your own logic)
    let mostPopular = null;
    if (products.length > 0 && (!category || category === 'All') && !search) {
      mostPopular = products.reduce((a, b) => (parseFloat(a.price) > parseFloat(b.price) ? a : b));
    }
    ensuregear_cartSession(req);
    res.render('store', {
      products,
      mostPopular,
      gear_cart: req.session.gear_cart,
      cart: req.session.gear_cart || [],
      selectedCategory: typeof category !== 'undefined' ? category : 'All',
      searchQuery: typeof search !== 'undefined' ? search : '',
      priceRange: typeof priceRange !== 'undefined' ? priceRange : 1000,
      categories,
      selectedSize: typeof req.query.size !== 'undefined' ? req.query.size : 'All',
      selectedSizeKids: typeof req.query.sizeKids !== 'undefined' ? req.query.sizeKids : 'All',
      sortBy: typeof sortBy !== 'undefined' ? sortBy : 'featured'
    });
  } catch (err) {
    console.error('Error fetching gear:', err);
    // Ensure categories is always defined, even on error
    let categories = [];
    try {
      const [catResults] = await connection.promise().query('SELECT DISTINCT category FROM gear WHERE category IS NOT NULL AND category != ""');
      categories = catResults.map(row => row.category).filter(Boolean);
    } catch (e) {}
    res.render('store', {
      products: [],
      mostPopular: null,
      gear_cart: req.session.gear_cart,
      cart: req.session.gear_cart || [],
      selectedCategory: 'All',
      searchQuery: '',
      priceRange: 1000,
      categories,
      selectedSize: 'All',
      selectedSizeKids: 'All',
      sortBy: 'featured'
    });
  }
});

// Hospitality Packages: Show only events as products
router.get('/store/hospitality', async (req, res) => {
  try {
    // Fetch all unique categories for sidebar/chips (for UI consistency)
    const [catResults] = await connection.promise().query('SELECT DISTINCT category FROM gear WHERE category IS NOT NULL AND category != ""');
    const categories = catResults.map(row => row.category).filter(Boolean);

    // Fetch events from the events table (assuming table name is 'events')
    const [eventResults] = await connection.promise().query('SELECT * FROM events');
    // Map events to product-like objects for the store grid
    const products = eventResults.map(event => ({
      id: event.event_id,
      name: event.event_name,
      image: event.event_image || 'news.png', // fallback image
      price: Number(event.price || event.ticket_price || 0).toFixed(2),
      category: 'Hospitality'
    }));

    ensuregear_cartSession(req);
    res.render('store', {
      products,
      mostPopular: null,
      gear_cart: req.session.gear_cart,
      cart: req.session.gear_cart || [],
      selectedCategory: 'Hospitality',
      searchQuery: '',
      priceRange: 300,
      categories,
      selectedSize: 'All',
      selectedSizeKids: 'All',
      sortBy: 'featured',
      isHospitality: true // for UI logic if needed
    });
  } catch (err) {
    console.error('Error fetching hospitality packages:', err);
    res.render('store', {
      products: [],
      mostPopular: null,
      gear_cart: req.session.gear_cart,
      cart: req.session.gear_cart || [],
      selectedCategory: 'Hospitality',
      searchQuery: '',
      priceRange: 300,
      categories: [],
      selectedSize: 'All',
      selectedSizeKids: 'All',
      sortBy: 'featured',
      isHospitality: true
    });
  }
});

// Add item to gear_cart
router.post('/gear_cart/add/:id', async (req, res) => {
  const gearId = parseInt(req.params.id, 10);
  const quantity = parseInt(req.body.quantity, 10) || 1;
  const size = req.body.size || null;
  if (isNaN(gearId)) return res.status(400).send('Invalid gear ID');

  try {
    const [results] = await connection.promise().query('SELECT * FROM gear WHERE gear_id = ?', [gearId]);
    if (results.length === 0) return res.status(404).send('Item not found');

    const item = {
      ...results[0],
      price_per_unit: Number(results[0].price_per_unit),
      size: size
    };

    ensuregear_cartSession(req);
    const gear_cart = req.session.gear_cart;
    const existingItem = gear_cart.find((c) => c.gear_id === gearId && c.size === size);

    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      gear_cart.push({ ...item, quantity });
    }

    if (req.xhr || req.headers.accept.indexOf('json') > -1) {
      res.json({ success: true });
    } else {
      res.redirect('/store?success=true');
    }
  } catch (err) {
    console.error('Error adding to gear_cart:', err);
    res.status(500).send('Database error');
  }
});

// View gear gear_cart
router.get('/gear_cart', (req, res) => {
  let isMember = false;
  if (req.session.user && req.session.user.role === 'member') {
    isMember = true;
  }
  res.render('gear_cart', { 
    gear_cart: req.session.gear_cart || [],
    cart: req.session.gear_cart || [],
    isMember,
    user: req.session.user 
  });
});

// Update gear_cart item quantity
router.post('/gear_cart/update/:id', (req, res) => {
  const gearId = parseInt(req.params.id, 10);
  const newQty = parseInt(req.body.quantity, 10);
  const size = req.body.size || null;
  ensuregear_cartSession(req);
  const item = req.session.gear_cart.find(i => i.gear_id === gearId && i.size === size);
  if (item && newQty > 0) {
    item.quantity = newQty;
  }
  res.redirect('/gear_cart');
});

// Remove item from gear_cart
router.post('/gear_cart/remove/:id', (req, res) => {
  const gearId = parseInt(req.params.id, 10);
  const size = req.body.size || null;
  ensuregear_cartSession(req);
  req.session.gear_cart = req.session.gear_cart.filter(i => !(i.gear_id === gearId && i.size === size));
  res.redirect('/gear-gear_cart');
});

// Checkout page
router.get('/payment', async (req, res) => {
  const gear_cart = req.session.gear_cart || [];
  const customer = req.session.user;
  if (!customer) return res.redirect('/login');
  if (gear_cart.length === 0) return res.redirect('/gear_cart');

  try {
    // Get user's cashback from user_memberships table
    const [membershipRows] = await connection.promise().query(`
      SELECT cashback_accumulated FROM user_memberships 
      WHERE user_id = ? AND status = 'active' 
      ORDER BY created_at DESC LIMIT 1
    `, [customer.user_id]);
    
    // Add cashback to customer object
    customer.cashback_balance = membershipRows.length > 0 ? membershipRows[0].cashback_accumulated : 0;

    connection.query('SELECT payment_method_id, method_name FROM payment_methods', (err, paymentModes) => {
      if (err) {
        console.error('DB error in /payment:', err);
        return res.status(500).send('Database error');
      }
      res.render('payment', { gear_cart, customer, paymentModes });
    });
  } catch (err) {
    console.error('Error fetching cashback:', err);
    res.status(500).send('Database error');
  }
});

// Payment processing (form submit)
router.post('/payment/process', async (req, res) => {
  const paymentMethod = req.body.paymentMethod;
  const applyCashback = parseFloat(req.body.applyCashback) || 0;
  const gear_cart = req.session.gear_cart || [];
  const user = req.session.user;
  if (!user || gear_cart.length === 0) {
    return res.status(400).send('Missing user or gear_cart data.');
  }

  const account_id = user.account_id;
  const user_id = user.user_id; // for payments/orders
  const shipping_address = user.address || '';

  try {
    // Validate cashback amount
    if (applyCashback > 0) {
      const [membershipRows] = await connection.promise().query(`
        SELECT cashback_accumulated FROM user_memberships 
        WHERE user_id = ? AND status = 'active' 
        ORDER BY created_at DESC LIMIT 1
      `, [user_id]);
      
      const availableCashback = membershipRows.length > 0 ? parseFloat(membershipRows[0].cashback_accumulated) : 0;
      if (applyCashback > availableCashback) {
        return res.status(400).send('Invalid cashback amount. You cannot use more cashback than available.');
      }
    }

    // Find payment_method_id
    const [pmResults] = await connection.promise().query(
      'SELECT payment_method_id FROM payment_methods WHERE LOWER(method_name) = LOWER(?) LIMIT 1',
      [paymentMethod]
    );
    if (pmResults.length === 0) {
      return res.status(400).send('Payment method not found. Please select a valid payment method.');
    }
    const payment_method_id = pmResults[0].payment_method_id;

    // Calculate totals
    const total_amount = gear_cart.reduce((sum, item) => sum + item.price_per_unit * item.quantity, 0);
    const discount_applied = applyCashback; // Use cashback as discount
    const final_amount = total_amount - discount_applied;

    // Insert order
    const [orderResult] = await connection.promise().query(
      'INSERT INTO orders (order_date, total_amount, discount_applied, final_amount, status, shipping_address, user_id) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [new Date(), total_amount, discount_applied, final_amount, 'pending', shipping_address, user_id]
    );
    const order_id = orderResult.insertId;

    // Insert order_items and update gear inventory
    for (const item of gear_cart) {
      await connection.promise().query(
        'INSERT INTO order_items (quantity, unit_price, total_price, order_id, gear_id) VALUES (?, ?, ?, ?, ?)',
        [item.quantity, item.price_per_unit, item.price_per_unit * item.quantity, order_id, item.gear_id]
      );
      // Optionally update inventory
      await connection.promise().query(
        'UPDATE gear SET gear_quantity = GREATEST(gear_quantity - ?, 0) WHERE gear_id = ?',
        [item.quantity, item.gear_id]
      );
    }

    // Insert payment record
    await connection.promise().query(
      'INSERT INTO payments (amount, payment_type, payment_status, transaction_reference, user_id, payment_method_id) VALUES (?, ?, ?, ?, ?, ?)',
      [final_amount, 'online', 'completed', `order-${order_id}`, user_id, payment_method_id]
    );

    // Update user's cashback accumulation and deduct used cashback
    const [membershipRows] = await connection.promise().query(
      `SELECT um.*, mt.cashback_rate FROM user_memberships um JOIN membership_tiers mt ON um.tier_id = mt.tier_id WHERE um.user_id = ? AND um.status = 'active' ORDER BY um.created_at DESC LIMIT 1`,
      [user_id]
    );
    if (membershipRows.length > 0) {
      const membership = membershipRows[0];
      
      // Deduct used cashback first
      if (applyCashback > 0) {
        await connection.promise().query(
          'UPDATE user_memberships SET cashback_accumulated = cashback_accumulated - ? WHERE membership_id = ?',
          [applyCashback, membership.membership_id]
        );
      }
      
      // Add new cashback earned from this purchase
      const cashbackEarned = final_amount * (parseFloat(membership.cashback_rate) / 100);
      if (cashbackEarned > 0) {
        await connection.promise().query(
          'UPDATE user_memberships SET cashback_accumulated = cashback_accumulated + ? WHERE membership_id = ?',
          [cashbackEarned, membership.membership_id]
        );
      }
    }

    // Decrement stock after successful payment
    for (const item of gear_cart) {
      await connection.promise().query(
        'UPDATE gear SET quantity = GREATEST(quantity - ?, 0) WHERE gear_id = ? OR id = ?',
        [item.quantity, item.gear_id, item.gear_id]
      );
    }

    // Clear gear_cart on successful payment
    req.session.gear_cart = [];

    // Send order confirmation email
    try {
      const { sendEmail } = require('../services/emailService');
      const [userResult] = await connection.promise().query(
        'SELECT first_name, surname, email FROM users WHERE user_id = ?',
        [user_id]
      );
      
      if (userResult.length > 0) {
        const user = userResult[0];
        const customerName = `${user.first_name} ${user.surname}`;
        
        // Format items for email
        const items = gear_cart.map(item => ({
          name: item.gear_name,
          quantity: item.quantity,
          price: item.price_per_unit.toFixed(2)
        }));
        
        await sendEmail(
          user.email,
          'orderConfirmation',
          customerName,
          order_id,
          final_amount,
          items
        );
      }
    } catch (emailError) {
      console.error('Error sending order confirmation email:', emailError);
      // Don't fail the request if email fails
    }

    res.redirect(`/thankyou?order_id=${order_id}`);
  } catch (err) {
    console.error('Error processing payment:', err);
    res.status(500).send('Payment processing error');
  }
});

// Thank you page
router.get('/thankyou', async (req, res) => {
  const orderId = req.query.order_id;
  if (!orderId) return res.redirect('/');

  try {
    const [orderResults] = await connection.promise().query(
      'SELECT * FROM orders WHERE order_id = ?',
      [orderId]
    );
    const order = orderResults[0];

    if (!order) return res.redirect('/');

    res.render('thankyou', { order });
  } catch (err) {
    console.error('Error fetching order:', err);
    res.status(500).send('Database error');
  }
});

// View gear_cart summary (AJAX for sidebar)
router.get('/gear_cart/summary', (req, res) => {
  ensuregear_cartSession(req);
  // Only send minimal info for summary
  const summary = (req.session.gear_cart || []).map(item => ({
    name: item.gear_name || item.name,
    quantity: item.quantity,
    size: item.size
  }));
  res.json(summary);
});

// Stripe Checkout session creation
router.post('/create-stripe-session', async (req, res) => {
  const gear_cart = req.session.gear_cart || [];
  const applyCashback = parseFloat(req.body.applyCashback) || 0;
  if (!gear_cart.length) return res.status(400).json({ error: 'gear_cart is empty' });

  try {
    const user = req.session.user;
    if (!user) return res.status(400).json({ error: 'User not logged in' });

    const user_id = user.user_id;
    const shipping_address = user.address || '';

    // Validate cashback amount
    if (applyCashback > 0) {
      const [membershipRows] = await connection.promise().query(`
        SELECT cashback_accumulated FROM user_memberships 
        WHERE user_id = ? AND status = 'active' 
        ORDER BY created_at DESC LIMIT 1
      `, [user_id]);
      
      const availableCashback = membershipRows.length > 0 ? parseFloat(membershipRows[0].cashback_accumulated) : 0;
      if (applyCashback > availableCashback) {
        return res.status(400).json({ error: 'Invalid cashback amount. You cannot use more cashback than available.' });
      }
    }

    // Calculate totals
    const total_amount = gear_cart.reduce((sum, item) => sum + item.price_per_unit * item.quantity, 0);
    const discount_applied = applyCashback; // Use cashback as discount
    const final_amount = total_amount - discount_applied;

    // Create order in database BEFORE Stripe session
    const [orderResult] = await connection.promise().query(
      'INSERT INTO orders (order_date, total_amount, discount_applied, final_amount, status, shipping_address, user_id) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [new Date(), total_amount, discount_applied, final_amount, 'pending', shipping_address, user_id]
    );
    const order_id = orderResult.insertId;

    // Store cashback usage in session for later processing
    req.session.pending_cashback_usage = {
      order_id: order_id,
      cashback_used: applyCashback
    };

    // Insert order_items
    for (const item of gear_cart) {
      await connection.promise().query(
        'INSERT INTO order_items (quantity, unit_price, total_price, order_id, gear_id) VALUES (?, ?, ?, ?, ?)',
        [item.quantity, item.price_per_unit, item.price_per_unit * item.quantity, order_id, item.gear_id]
      );
    }

    // Only charge the discounted total after cashback
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [{
        price_data: {
          currency: 'sgd',
          product_data: {
            name: 'Order Total (after cashback)',
          },
          unit_amount: Math.round(final_amount * 100),
        },
        quantity: 1,
      }],
      mode: 'payment',
      success_url: req.protocol + '://' + req.get('host') + '/payment/success?session_id={CHECKOUT_SESSION_ID}&order_id=' + order_id,
      cancel_url: req.protocol + '://' + req.get('host') + '/payment?cancelled=true',
    });
    res.json({ id: session.id, url: session.url });
  } catch (err) {
    console.error('Stripe session error:', err);
    res.status(500).json({ error: 'Stripe error' });
  }
});

// Stripe payment success page
router.get('/payment/success', async (req, res) => {
  try {
    const user = req.session.user;
    const order_id = req.query.order_id;
    const session_id = req.query.session_id;
    
    if (user && order_id) {
      const user_id = user.user_id;
      
      // Get the specific order
      const [orderResults] = await connection.promise().query(
        'SELECT * FROM orders WHERE order_id = ? AND user_id = ?',
        [order_id, user_id]
      );
      const order = orderResults[0];
      
      if (order) {
        // Mark order as confirmed
        await connection.promise().query(
          'UPDATE orders SET status = "confirmed" WHERE order_id = ?',
          [order_id]
        );

        // Record the payment transaction
        if (session_id) {
          try {
            const session = await stripe.checkout.sessions.retrieve(session_id);
            
            // Get or create payment method for Stripe
            let [paymentMethodResults] = await connection.promise().query(
              'SELECT payment_method_id FROM payment_methods WHERE method_name = "Stripe"'
            );
            
            let paymentMethodId;
            if (paymentMethodResults.length === 0) {
              // Create Stripe payment method if it doesn't exist
              const [insertResult] = await connection.promise().query(
                'INSERT INTO payment_methods (method_name, is_active) VALUES ("Stripe", 1)'
              );
              paymentMethodId = insertResult.insertId;
            } else {
              paymentMethodId = paymentMethodResults[0].payment_method_id;
            }
            
            // Record the payment
            await connection.promise().query(`
              INSERT INTO payments (
                amount, payment_type, payment_status, transaction_reference, 
                payment_date, user_id, payment_method_id, order_id
              ) VALUES (?, 'gear', 'completed', ?, NOW(), ?, ?, ?)
            `, [
              order.final_amount,
              session.payment_intent,
              user_id,
              paymentMethodId,
              order_id
            ]);
          } catch (stripeError) {
            console.error('Error retrieving Stripe session:', stripeError);
          }
        }

        // Update cashback accumulation and handle used cashback
        const [membershipRows] = await connection.promise().query(
          `SELECT um.*, mt.cashback_rate FROM user_memberships um JOIN membership_tiers mt ON um.tier_id = mt.tier_id WHERE um.user_id = ? AND um.status = 'active' ORDER BY um.created_at DESC LIMIT 1`,
          [user_id]
        );
        
        if (membershipRows.length > 0) {
          const membership = membershipRows[0];
          
          // Check if there was cashback used for this order
          if (req.session.pending_cashback_usage && req.session.pending_cashback_usage.order_id == order_id) {
            const cashbackUsed = req.session.pending_cashback_usage.cashback_used;
            if (cashbackUsed > 0) {
              // Deduct used cashback
              await connection.promise().query(
                'UPDATE user_memberships SET cashback_accumulated = cashback_accumulated - ? WHERE membership_id = ?',
                [cashbackUsed, membership.membership_id]
              );
            }
            // Clear the pending cashback usage
            delete req.session.pending_cashback_usage;
          }
          
          const cashbackRate = parseFloat(membership.cashback_rate) || 0;
          
          if (cashbackRate > 0) {
            const cashbackEarned = parseFloat(order.final_amount) * cashbackRate / 100;
            // Add new cashback earned
            await connection.promise().query(
              'UPDATE user_memberships SET cashback_accumulated = cashback_accumulated + ? WHERE membership_id = ?',
              [cashbackEarned, membership.membership_id]
            );
            // Update session value for immediate reflection
            if (req.session.user) {
              const [membershipRows2] = await connection.promise().query(
                'SELECT cashback_accumulated FROM user_memberships WHERE user_id = ? AND status = "active" ORDER BY created_at DESC LIMIT 1',
                [user_id]
              );
              if (membershipRows2.length > 0) {
                req.session.user.cashback_accumulated = membershipRows2[0].cashback_accumulated;
              }
            }
          }
        }

        // Deduct stock for each item in the order
        const [orderItems] = await connection.promise().query(
          'SELECT * FROM order_items WHERE order_id = ?',
          [order_id]
        );
        for (const item of orderItems) {
          await connection.promise().query(
            'UPDATE gear SET gear_quantity = GREATEST(gear_quantity - ?, 0) WHERE gear_id = ?',
            [item.quantity, item.gear_id]
          );
        }
        
        // Clear the gear_cart after successful payment
        req.session.gear_cart = [];

        // Send order confirmation email for Stripe payment
        try {
          const { sendEmail } = require('../services/emailService');
          const [userResult] = await connection.promise().query(
            'SELECT first_name, surname, email FROM users WHERE user_id = ?',
            [user_id]
          );
          
          if (userResult.length > 0) {
            const user = userResult[0];
            const customerName = `${user.first_name} ${user.surname}`;
            
            // Get order items for email
            const [orderItems] = await connection.promise().query(`
              SELECT oi.*, g.gear_name 
              FROM order_items oi 
              JOIN gear g ON oi.gear_id = g.gear_id 
              WHERE oi.order_id = ?
            `, [order_id]);
            
            const items = orderItems.map(item => ({
              name: item.gear_name,
              quantity: item.quantity,
              price: parseFloat(item.unit_price || 0).toFixed(2)
            }));
            
            await sendEmail(
              user.email,
              'orderConfirmation',
              customerName,
              order_id,
              final_amount,
              items
            );
          }
        } catch (emailError) {
          console.error('Error sending Stripe order confirmation email:', emailError);
          // Don't fail the request if email fails
        }
      }
    }
  } catch (err) {
    console.error('Error updating cashback after Stripe payment:', err);
  }
  res.render('paymentsuccess');
});

module.exports = router;